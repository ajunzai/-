1. 垃圾回收机制gc？（可达性）
    解答：可达性，从ROOT开始。通过对象是否有传入的引用链来判断是否可被回收，无法访问的数据块都会失效
         内部算法——”标记-清除“
         1）获取根并标记（根下一层）
         2）然后访问并标记所有来自它们的引用（根下一层的引用，继续下一层）
         3）所有访问的对想都被记住，以便以后访问同一个对象两次
         4）除标记的对象，都被删除
      优化：分代回收，增量回收，cpu空闲时间回收
      
2. 前端路由实现，hash和histroy区别？ （都是通过监听或者触发事件来更替html）
    hash：是#后面的那部分，改变不会引起页面刷新，通过hashchange事件监听URL变化返回不同页面
    history：提供了pushState和replaceState方法，但是这两个方法改变了URL不会引起页面刷新。还提供了hashchange和popstate事件，但是popstate事件只有在浏览器前进后腿才能监听到。
             用最前面两个事件不会触发popstate事件，好在我们可以拦截pushstate/replacestate的调用和a标签的变化来检测URL变化
      实现：初始化的时候给a标签注册点击事件更改路径并且替换页面内容

3. eventloop里面的宏任务和微任务？
    解答：事件循环，是指浏览器或node解决JavaScript单线程运行时不会阻塞的一种机制，也就是经常说的异步原理
    1）eventlopp  JavaScript中任务被分为两种，宏任务和微任务    
        MacroTask（宏任务）————script全部代码、setTimeout、setInterval、I/O、UI Rendering
        MicroTask（微任务）————process.nextTick、promise、MutationObserver
    2）浏览器的EventLoop JavaScript有一个main thread主线程和 call-stack调用栈（执行栈后进先出），所有的任务都会放到调用栈等待主线程执行
    3）JavaScript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行
    总结：执行栈执行完同步任务后，如果执行栈为空就去执行Task，每次宏任务执行完毕后，检查微任务队列是否为空，如果不为空，会按照先进先出的全部执行微任务，微任务完成后队列为null，然后如此循环
	
4. http和http2？
	https和http区别
		1.HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
		2.HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
		3.HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
		4.HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

5. 输入url到浏览器做了什么？（把重构和回流了解详细）
	1）输入网址会进入到网络进程，浏览器对当前页面发出了beforeunload事件。
    2）识别IP地址发送请求
        a.构造http请求，包括请求头，请求体
        b.匹配缓存，本地缓存或者协商缓存返回304，无则发送请求 ！！！
        c.排队，浏览器只能同时发送6个请求，
        d.tcp三次握手 ！！！！
        e.服务器响应，处理完后服务器返回请求响应头，以及响应体
        f.通知浏览器进程
    3）浏览器进程通知渲染进程
        浏览器根据响应头content-type做处理，如果是text/html,则发送提交导航给渲染进程，渲染进程收到后，会与网络进程建立数据管道，最后渲染进程会告诉浏览器进程可以接受数据了，浏览器收到渲染进程消息后，就开始更新页面状态，移除旧文档
    4）渲染进程从网络进程接收数据并解析
        a.html解析成dom数结构 ！！！浏览器使用状态机将dom文本经过token解析、语法解析、生成语法树三个步骤生成dom对象结构。
        b.css样式表转化为stylesheets，计算出dom节点的样式。dom的解析由上至下，遇到css和js都会等解析完成才继续接收，属于一个优化点
        c.创建layout树，并计算元素的布局信息
        d.对布局树分层，生成分层树
        e.每个图层生成绘制列表，并将其提交到合成线程
        f.合成线程将图层分成图块，并将图块转换成位图。
        g.合成线程发送绘制图块命令 DrawQuad 给浏览器进程。浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。
    
6. BFC触发 和 解决方法?
    解答：块格式化上下文 生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。
    场景：  1）外边距折叠问题————把两个元素置于不同的BFC进行隔离 overflow：hidden
           2）清楚浮动————容器因float浮动脱离文档流，导致容器元素没有被撑大 overflow：hidden
           3）阻止普通元素被浮动元素覆盖（可以用自适应两栏布局）————给普通元素增加BFC，overflow：hiidden
    触发：浮动、绝对定位、行内块元素、overflow值不为visible、等一系列。
    
7. 前端安全问题，注入 和 CSRF、XSS？
	解答：1）CSRF 跨站请求伪造 Token验证 隐藏令牌（放在你header中）
		 2）XSS 跨域脚本攻击——在web页面里插入恶意script代码。，防御对html转义，对所有非字母和数字的字符转义成小于256的ascii字符。url用encodeUrlComponent（）编码
		 
8. js三态，多态，继承，封装。 自己怎么理解面向对象，有去用过吗？
9. 对es6  的map、set、Reflect、其它一些的使用和理解？
10. 协商缓存和强缓存返回状态码是304？
