1. 垃圾回收机制gc？（可达性）
    解答：可达性，从ROOT开始。通过对象是否有传入的引用链来判断是否可被回收，无法访问的数据块都会失效
         内部算法——”标记-清除“
         1）获取根并标记（根下一层）
         2）然后访问并标记所有来自它们的引用（根下一层的引用，继续下一层）
         3）所有访问的对想都被记住，以便以后访问同一个对象两次
         4）除标记的对象，都被删除
      优化：分代回收，增量回收，cpu空闲时间回收
      
2. 前端路由实现，hash和histroy区别？ （都是通过监听或者触发事件来更替html）
    hash：是#后面的那部分，改变不会引起页面刷新，通过hashchange事件监听URL变化返回不同页面
    history：提供了pushState和replaceState方法，但是这两个方法改变了URL不会引起页面刷新。还提供了hashchange和popstate事件，但是popstate事件只有在浏览器前进后腿才能监听到。
             用最前面两个事件不会触发popstate事件，好在我们可以拦截pushstate/replacestate的调用和a标签的变化来检测URL变化
      实现：初始化的时候给a标签注册点击事件更改路径并且替换页面内容

3. eventloop里面的宏任务和微任务？
    解答：事件循环，是指浏览器或node解决JavaScript单线程运行时不会阻塞的一种机制，也就是经常说的异步原理
    1）eventlopp  JavaScript中任务被分为两种，宏任务和微任务    
        MacroTask（宏任务）————script全部代码、setTimeout、setInterval、I/O、UI Rendering
        MicroTask（微任务）————process.nextTick、promise、MutationObserver
    2）浏览器的EventLoop JavaScript有一个main thread主线程和 call-stack调用栈（执行栈后进先出），所有的任务都会放到调用栈等待主线程执行
    3）JavaScript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行
    总结：执行栈执行完同步任务后，如果执行栈为空就去执行Task，每次宏任务执行完毕后，检查微任务队列是否为空，如果不为空，会按照先进先出的全部执行微任务，微任务完成后队列为null，然后如此循环
	
4. http和http2？
	https和http区别
		1.HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
		2.HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
		3.HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
		4.HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

5. 输入url到浏览器做了什么？（把重构和回流了解详细）
	1）输入网址会进入到网络进程，浏览器对当前页面发出了beforeunload事件。
    2）识别IP地址发送请求
    	b.匹配缓存，本地缓存或者协商缓存返回304，无则发送请求 ！！！
        a.向DNS服务器发送域名，匹配相应的IP地址，然后打在协议上。浏览器缓存解析、本地hosts文件解析、操作系统解析、路由器解析、根域名服务器解析。
    3） tcp三次握手 用以同步客户端和服务端的序列号和确认号！！！
    4） 发送HTTP请求报文。
    4.1）服务器响应，处理完后服务器返回请求响应头，以及响应体
        f.通知浏览器进程
    5）浏览器进程通知渲染进程
        浏览器根据响应头content-type做处理，如果是text/html,则发送提交导航给渲染进程，渲染进程收到后，会与网络进程建立数据管道，最后渲染进程会告诉浏览器进程可以接受数据了，浏览器收到渲染进程消息后，就开始更新页面状态，移除旧文档
    5.1）渲染进程从网络进程接收数据并解析（拿到html后，开始渲染）
        a.html解析，将二进制编码转换utf-8成字符串，预解析-比如img标签的src属性，提前识别请求资源的属性加入请求队列中。词法解析和构建树是并行操作，一个一个创建dom节点，生成dom树。
		异步加载浏览器会通过DOMContentLoaded事件通知DOM解析完成。
        b.css样式表转化为stylesheets，对下载好的css解析并进行标记。计算出dom节点的样式，匹配规则是从右到左的顺序。
        c.dom树和css树合并成渲染树（会忽略display：none的节点。包含计算尺寸，确定css权重最高样式，渲染阻塞，dom的解析由上至下，
	      1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了
	      2.Dom构建遇到script会暂停，js依赖css样式浏览器会延迟脚本。
        d？.根据渲染数计算每一个节点的信息进行布局，调用渲染器的paint（）方法在屏幕显示其内容
        e？.合并渲染。每个图层生成绘制列表，并将其提交到合成线程，合成线程将图层分成图块，并将图块转换成位图。
        f.回流和重绘，回流——布局发生影响后重新渲染，回流必然产生重绘，重绘——改变背景色不影响周围元素变化
    6）当数据传送完毕，需要断开tcp连接，发起四次挥手
    	a.发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)
	b.被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)
	c.被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)
	d.发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)

6. BFC触发 和 解决方法?
    解答：块格式化上下文它是一个独立渲染区域，也是浮动元素与其他元素的交互限定区域。
    场景：  1）外边距折叠问题————把两个元素置于不同的BFC进行隔离 overflow：hidden
           2）清楚浮动————容器因float浮动脱离文档流，导致容器元素没有被撑大 overflow：hidden
           3）阻止普通元素被浮动元素覆盖（可以用自适应两栏布局）————给普通元素增加BFC，overflow：hiidden
    触发：浮动、绝对定位、行内块元素、overflow值不为visible、等一系列。
    
7. 前端安全问题，注入 和 CSRF、XSS？
	解答：1）CSRF 跨站请求伪造 Token验证 隐藏令牌（放在你header中）
		 2）XSS 跨域脚本攻击——在web页面里插入恶意script代码。，防御对html转义，对所有非字母和数字的字符转义成小于256的ascii字符。url用encodeUrlComponent（）编码
		 
8. js三态，多态，继承，封装。 自己怎么理解面向对象，有去用过吗？
9. 对es6  的map、set、Reflect、其它一些的使用和理解？
10. 协商缓存和强缓存返回状态码是304？
	https://www.jianshu.com/p/54cc04190252
	所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：
	1.打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
	2.普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
	3.强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。
    解答：强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存
        有Last-Modified还用ETag，因为Last-Modified不能识别秒单位的修改
        有ETag还用Last-Modified，因为图片的修改通过扫描生成，产生时间比对比修改时间要多
    强缓存——不会向服务器发送请求返回200状态码，设置HTTP头 Expires和Cache-Control
    前者缓存的目标时间（http1.0），后者缓存倒计时max-age=300（http1.1）优先级高。
    协商缓存——强缓存失效后，浏览器携带缓存标识发请求，有两种情况，304和Not Modified、200和请求结果，设置HTTP头 Last-Modified和Etag，前者访问资源后服务器会返回最后修改时间，下次请求带上用if-Modified-Since对比修改时间是否相同，返回304，读取缓存，反之，返回200，请求资源。后者为资源文件的唯一标识，下次请求带上if-None—Match。服务器还是优先考虑Etag。
 
11.闭包的理解？
    解答：函数内部返回一个函数，且这个函数可以访问函数内部的变量。
    	可以创建私有变量。产生闭包的可能性————返回一个函数，作为函数参数传递，回调函数（定时器，事件监听），IIFE（立即执行函数）

12.原型链
	1.原型对象和构造函数的关系
		a)每定义一个函数的时候，会天生自带一个prototype属性，这个属性指向函数的原型对象。
		b)当函数经过new调用时，这个函数就成为构造函数，返回一个全新的实列对象，这个实列对象有一个__proto__属性，指向构造函数的原型对象。		
	2.描述原型链
		a)每个对象都有__proto__属性，此属性指向该对象的构造函数的原型。对象可以通过__proto__与上游的构造函数的原型对象连接起来，而上游的原型对象也有一个__proto__，这样形成原型链
		b)对象的hasOwnProperty()来检查对象自身中是否含有这个属性
		c)使用in检查对象中是否含有某个属性。

13. 首屏加载优化
	解答： 1. 在 HTML 内实现 Loading 态或者骨架屏；
		2.去掉外联 css；
		3.缓存基础框架；
		4.使用动态 polyfill； <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=Map,Set"></script>
		5.使用 SplitChunksPlugin 拆分公共代码；
		6.正确地使用 Webpack 4.0 的 Tree Shaking；
		7.使用动态 import，切分页面代码，减小首屏 JS 体积；
		8.编译到 ES2015+，提高代码运行效率，减小体积；
		9.使用 lazyload 和 placeholder 提升加载体验。
		
14.跨域的解决方法
	解答：1.JSONP(利用 script 标签的异步加载实现的)
	      2.document.domain 基础域名相同 子域名不同
	      3.window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name
	      4.Hash（window.location.hash + iframe） 不同域之间利⽤ iframe的location.hash传值，相同域之间直接js访问来通信
	      5.window.postMessage (H5中新增的)
	      6.WebSocket
	      7.CORS 再请求头加上Access-Control-Allow-Origin
	      8.Nginx反向代理

15.git中rebase和merge的区别？
	解答：
	1.merge的特点：⾃动创建⼀个新的commit 如果合并的时候遇到冲突，仅需要修改后重新commit 
		优点：记录了真实的commit情况，包括每个分⽀的详情 
		缺点：因为每次merge会⾃动产⽣⼀个merge commit，所以在使⽤⼀些git 的GUI tools，特别是commit⽐较频繁 时，（看到分⽀很杂乱）。
	2.rebase 特点：会合并之前的commit历史 
		优点：得到更简洁的项⽬历史，去掉了merge commit 
		缺点：如果合并出现代码问题不容易定位，因为re-write了history
	因此,当需要保留详细的合并信息的时候建议使⽤git merge，特别是需要将分⽀合并进⼊master分⽀时；
	当发现⾃⼰修改某个功能时，频繁进⾏了git commit提交时，发现其实过多的提交信息没有必要时，可以尝试git rebase.
http://47.98.159.95/my_blog/nav/ 神三元的博客
